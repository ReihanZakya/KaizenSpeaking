Index: app/src/main/java/com/example/kaizenspeaking/ui/analyze/AnalyzeFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.kaizenspeaking.ui.analyze\r\n\r\nimport android.content.Context\r\nimport android.content.Intent\r\nimport android.os.Bundle\r\nimport android.os.Looper\r\nimport android.view.LayoutInflater\r\nimport android.view.View\r\nimport android.view.ViewGroup\r\nimport android.widget.Toast\r\nimport androidx.fragment.app.Fragment\r\nimport com.example.kaizenspeaking.R\r\nimport com.example.kaizenspeaking.databinding.FragmentAnalyzeBinding\r\nimport java.io.File\r\nimport android.Manifest\r\nimport android.app.AlertDialog\r\nimport android.app.NotificationChannel\r\nimport android.app.NotificationManager\r\nimport android.content.BroadcastReceiver\r\nimport android.content.IntentFilter\r\nimport android.content.pm.PackageManager\r\nimport android.media.MediaRecorder\r\nimport android.os.Build\r\nimport androidx.core.app.ActivityCompat\r\nimport androidx.core.content.ContextCompat\r\nimport android.os.Handler\r\nimport androidx.core.app.NotificationCompat\r\nimport androidx.localbroadcastmanager.content.LocalBroadcastManager\r\nimport androidx.navigation.NavDeepLinkBuilder\r\nimport com.example.kaizenspeaking.ui.analyze.data.response.AnalyzeResponse\r\nimport com.example.kaizenspeaking.helper.SharedPreferencesHelper\r\nimport com.example.kaizenspeaking.ui.analyze.Service.UploadForegroundService\r\nimport com.example.kaizenspeaking.ui.instructions.OnboardingActivity\r\n\r\nclass AnalyzeFragment : Fragment() {\r\n\r\n    private var _binding: FragmentAnalyzeBinding? = null\r\n\r\n    private val binding get() = _binding!!\r\n\r\n    private var state = 0\r\n    private val handler = Handler(Looper.getMainLooper())\r\n    private var hasShownOnboarding = false\r\n\r\n    companion object {\r\n        private const val PREFS_NAME = \"OnboardingPrefs\"\r\n        private const val KEY_HAS_SHOWN_ONBOARDING = \"hasShownOnboarding\"\r\n        private const val ONBOARDING_DELAY = 5000L // 5 seconds\r\n    }\r\n\r\n    //audio\r\n    private var mediaRecorder: MediaRecorder? = null\r\n    private var audioFile: File? = null\r\n    private var tempFile: File? = null\r\n\r\n    private val REQUEST_CODE_RECORD_AUDIO = 1\r\n\r\n    // Time\r\n    private var isRunning = false\r\n    private var elapsedTime: Long = 0L\r\n    private var startTime: Long = 0L\r\n    private lateinit var handlerTimer: Handler\r\n    private lateinit var runnable: Runnable\r\n\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater,\r\n        container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View {\r\n        _binding = FragmentAnalyzeBinding.inflate(inflater, container, false)\r\n        val root: View = binding.root\r\n\r\n        return root\r\n    }\r\n\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        super.onViewCreated(view, savedInstanceState)\r\n\r\n        checkAndShowOnboarding()\r\n        checkAudioPermission()\r\n\r\n        binding.btnViewIntructions.setOnClickListener {\r\n            startOnboardingManually()\r\n        }\r\n\r\n\r\n//        button\r\n        binding.btnMultiFunction.text = getString(R.string.start_record)\r\n        binding.btnMultiFunction.setTextColor(ContextCompat.getColor(requireContext(), R.color.black))\r\n        binding.btnMultiFunction.setBackgroundResource(R.drawable.btn_gray)\r\n\r\n//        mic\r\n        binding.imgMic.setImageResource(R.drawable.mic_off)\r\n\r\n        binding.btnMultiFunction.setOnClickListener {\r\n            handleButtonClick()\r\n        }\r\n    }\r\n    private fun checkAudioPermission() {\r\n        if (ContextCompat.checkSelfPermission(\r\n                requireContext(),\r\n                Manifest.permission.RECORD_AUDIO\r\n            ) != PackageManager.PERMISSION_GRANTED\r\n        ) {\r\n            ActivityCompat.requestPermissions(\r\n                requireActivity(),\r\n                arrayOf(Manifest.permission.RECORD_AUDIO),\r\n                REQUEST_CODE_RECORD_AUDIO\r\n            )\r\n        } else {\r\n            // Permission already granted, perform your action\r\n            performAction()\r\n        }\r\n    }\r\n    private fun performAction() {\r\n        // Your logic when permission is granted\r\n        Toast.makeText(requireContext(), \"Permission granted!\", Toast.LENGTH_SHORT).show()\r\n    }\r\n\r\n    override fun onRequestPermissionsResult(\r\n        requestCode: Int,\r\n        permissions: Array<out String>,\r\n        grantResults: IntArray\r\n    ) {\r\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\r\n\r\n        if (requestCode == REQUEST_CODE_RECORD_AUDIO) {\r\n            if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                // Refresh fragment after permission granted\r\n                refreshFragment()\r\n            } else {\r\n                Toast.makeText(\r\n                    requireContext(),\r\n                    \"Permission denied. Please grant permission to proceed.\",\r\n                    Toast.LENGTH_SHORT\r\n                ).show()\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun refreshFragment() {\r\n        parentFragmentManager.beginTransaction().apply {\r\n            detach(this@AnalyzeFragment)\r\n            attach(this@AnalyzeFragment)\r\n            commit()\r\n        }\r\n    }\r\n\r\n    private fun startOnboardingManually() {\r\n        val intent = Intent(requireContext(), OnboardingActivity::class.java).apply {\r\n            putExtra(\"manual_start\", true) // Flag to indicate manual start\r\n        }\r\n        startActivity(intent)\r\n    }\r\n\r\n    private fun checkAndShowOnboarding() {\r\n        // Check if onboarding has been shown before\r\n        val prefs = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)\r\n        hasShownOnboarding = prefs.getBoolean(KEY_HAS_SHOWN_ONBOARDING, false)\r\n\r\n        if (!hasShownOnboarding) {\r\n            // Set timer to show onboarding after 5 seconds\r\n            handler.postDelayed({\r\n                if (isAdded && !hasShownOnboarding) { // Check if fragment is still attached\r\n                    showOnboarding()\r\n                }\r\n            }, ONBOARDING_DELAY)\r\n        }\r\n    }\r\n\r\n    private fun showOnboarding() {\r\n        if (!hasShownOnboarding) {\r\n            // Mark onboarding as shown\r\n            requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)\r\n                .edit()\r\n                .putBoolean(KEY_HAS_SHOWN_ONBOARDING, true)\r\n                .apply()\r\n\r\n            hasShownOnboarding = true\r\n        }\r\n\r\n        // Show onboarding activity\r\n        startActivity(Intent(requireContext(), OnboardingActivity::class.java))\r\n    }\r\n\r\n    private fun handleButtonClick() {\r\n        when (state) {\r\n            0 -> {\r\n                val fileName = binding.etTopic.text.toString()\r\n                if (fileName.isNotEmpty()) {\r\n                    binding.btnMultiFunction.text = getString(R.string.stop)\r\n                    binding.btnMultiFunction.setTextColor(ContextCompat.getColor(requireContext(), R.color.white))\r\n                    binding.btnMultiFunction.setBackgroundResource(R.drawable.btn_red)\r\n                    binding.imgMic.setImageResource(R.drawable.mic_on)\r\n                    startRecording(fileName)\r\n                    // Memulai Stopwatch\r\n                    startTime = System.currentTimeMillis() - elapsedTime\r\n                    isRunning = true\r\n                    startStopwatch()\r\n                    state = 1\r\n                }else{\r\n                    Toast.makeText(requireContext(), \"Mohom masukkan topic terlebih dahulu\", Toast.LENGTH_SHORT).show()\r\n                    state = 0\r\n                }\r\n\r\n            }\r\n            1 -> {\r\n                binding.btnMultiFunction.text = getString(R.string.analyze)\r\n                binding.btnMultiFunction.setTextColor(ContextCompat.getColor(requireContext(), R.color.red))\r\n                binding.btnMultiFunction.setBackgroundResource(R.drawable.btn_gray)\r\n                binding.imgMic.setImageResource(R.drawable.mic_off)\r\n                stopRecording()\r\n                state = 2\r\n            }\r\n            2 -> {\r\n                binding.btnMultiFunction.text = getString(R.string.start_record)\r\n                binding.btnMultiFunction.setTextColor(ContextCompat.getColor(requireContext(), R.color.black))\r\n                sendDataToApi()\r\n                elapsedTime = 0L // Reset waktu\r\n                binding.tvTimer.text = \"00:00\"\r\n                state = 0\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun startRecording(fileName: String) {\r\n\r\n        try {\r\n            // Buat file sementara di cache directory\r\n            val cacheDir = requireContext().cacheDir\r\n            tempFile = File.createTempFile(fileName, \".m4a\", cacheDir)\r\n\r\n            mediaRecorder = MediaRecorder().apply {\r\n                setAudioSource(MediaRecorder.AudioSource.MIC)\r\n                setOutputFormat(MediaRecorder.OutputFormat.MPEG_4)\r\n                setAudioEncoder(MediaRecorder.AudioEncoder.AAC)\r\n                setOutputFile(tempFile?.absolutePath)\r\n                prepare()\r\n                start()\r\n            }\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n            Toast.makeText(requireContext(), \"Gagal merekam audio\", Toast.LENGTH_SHORT).show()\r\n        }\r\n    }\r\n\r\n    private fun startStopwatch() {\r\n        handlerTimer = Handler()\r\n        runnable = object : Runnable {\r\n            override fun run() {\r\n                if (isRunning) {\r\n                    val now = System.currentTimeMillis()\r\n                    elapsedTime = now - startTime\r\n                    binding.tvTimer.text = formatTime(elapsedTime)\r\n                    handlerTimer.postDelayed(this, 1000) // Update setiap detik\r\n                }\r\n            }\r\n        }\r\n        handlerTimer.post(runnable)\r\n    }\r\n\r\n    private fun formatTime(ms: Long): String {\r\n        val seconds = (ms / 1000) % 60\r\n        val minutes = (ms / (1000 * 60)) % 60\r\n        return String.format(\"%02d:%02d\", minutes, seconds)\r\n    }\r\n\r\n\r\n    private fun stopRecording() {\r\n        try {\r\n            mediaRecorder?.apply {\r\n                stop()\r\n                release()\r\n            }\r\n            // Menghentikan Stopwatch\r\n            isRunning = false\r\n            handlerTimer.removeCallbacks(runnable)\r\n            mediaRecorder = null\r\n            Toast.makeText(requireContext(), \"Recording stopped\", Toast.LENGTH_LONG).show()\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n            Toast.makeText(requireContext(), \"Gagal menghentikan perekaman\", Toast.LENGTH_LONG).show()\r\n        }\r\n    }\r\n\r\n\r\n\r\n    private fun sendDataToApi() {\r\n        val topic = binding.etTopic.text.toString()\r\n        val deviceId = SharedPreferencesHelper.getFromSharedPreferences(requireContext(), \"device_id\") ?: \"unknown_device\"\r\n\r\n        if (tempFile == null || !tempFile!!.exists()) {\r\n            Toast.makeText(requireContext(), \"File audio tidak ditemukan\", Toast.LENGTH_LONG).show()\r\n            return\r\n        }\r\n\r\n        val serviceIntent = Intent(requireContext(), UploadForegroundService::class.java).apply {\r\n            putExtra(UploadForegroundService.EXTRA_TOPIC, topic)\r\n            putExtra(UploadForegroundService.EXTRA_DEVICE_ID, deviceId)\r\n            putExtra(UploadForegroundService.EXTRA_FILE_PATH, tempFile!!.absolutePath)\r\n        }\r\n\r\n        val alertDialog = AlertDialog.Builder(requireContext())\r\n            .setTitle(\"Processing Analysis\")\r\n            .setMessage(\"Proses analisis sedang berlangsung, cek notifikasi untuk melihat hasil analisis\")\r\n            .setCancelable(true) // Tidak bisa ditutup oleh pengguna\r\n            .create()\r\n        alertDialog.show()\r\n\r\n        // Monitor hasil dengan BroadcastReceiver\r\n        val receiver = object : BroadcastReceiver() {\r\n            override fun onReceive(context: Context, intent: Intent) {\r\n                val result: AnalyzeResponse? = intent.getParcelableExtra(\"result\")\r\n                alertDialog.dismiss()\r\n\r\n\r\n                if (result != null) {\r\n                    // Tampilkan notifikasi untuk berpindah halaman\r\n                    val pendingIntent = NavDeepLinkBuilder(requireContext())\r\n                        .setGraph(R.navigation.mobile_navigation)\r\n                        .setDestination(R.id.analyzeResultFragment)\r\n                        .setArguments(Bundle().apply { putParcelable(\"result\", result) })\r\n                        .createPendingIntent()\r\n\r\n                    val notificationManager = requireContext().getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\r\n                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n                        val channel = NotificationChannel(\r\n                            \"analysis_channel\",\r\n                            \"Analysis Notifications\",\r\n                            NotificationManager.IMPORTANCE_HIGH\r\n                        )\r\n                        notificationManager.createNotificationChannel(channel)\r\n                    }\r\n\r\n                    val notification = NotificationCompat.Builder(requireContext(), \"analysis_channel\")\r\n                        .setSmallIcon(R.drawable.ic_notifications_black_24dp)\r\n                        .setContentTitle(\"Analisis Selesai\")\r\n                        .setContentText(\"Klik untuk melihat hasil analisis\")\r\n                        .setContentIntent(pendingIntent)\r\n                        .setAutoCancel(false)\r\n                        .build()\r\n\r\n                    notificationManager.notify(2, notification) // ID notifikasi harus unik\r\n                } else {\r\n                    Toast.makeText(requireContext(), \"Gagal menganalisis data\", Toast.LENGTH_LONG).show()\r\n                }\r\n            }\r\n        }\r\n\r\n        LocalBroadcastManager.getInstance(requireContext()).registerReceiver(receiver, IntentFilter(\"ANALYZE_RESULT\"))\r\n\r\n        ContextCompat.startForegroundService(requireContext(), serviceIntent)\r\n    }\r\n\r\n\r\n    override fun onDestroyView() {\r\n        super.onDestroyView()\r\n        _binding = null\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/kaizenspeaking/ui/analyze/AnalyzeFragment.kt b/app/src/main/java/com/example/kaizenspeaking/ui/analyze/AnalyzeFragment.kt
--- a/app/src/main/java/com/example/kaizenspeaking/ui/analyze/AnalyzeFragment.kt	(revision 06bdbe1ca1ccd161f0e4415756eae062abe769cf)
+++ b/app/src/main/java/com/example/kaizenspeaking/ui/analyze/AnalyzeFragment.kt	(date 1733110142060)
@@ -31,6 +31,7 @@
 import com.example.kaizenspeaking.helper.SharedPreferencesHelper
 import com.example.kaizenspeaking.ui.analyze.Service.UploadForegroundService
 import com.example.kaizenspeaking.ui.instructions.OnboardingActivity
+import com.example.kaizenspeaking.utils.UserSession
 
 class AnalyzeFragment : Fragment() {
 
@@ -288,6 +289,8 @@
     private fun sendDataToApi() {
         val topic = binding.etTopic.text.toString()
         val deviceId = SharedPreferencesHelper.getFromSharedPreferences(requireContext(), "device_id") ?: "unknown_device"
+//        val userId = UserSession.isLoggedIn(requireContext(), ) ?: "anda_belum_login"
+        val userId = "77c7d604-4457-4496-9131-e36ae1d89d68"
 
         if (tempFile == null || !tempFile!!.exists()) {
             Toast.makeText(requireContext(), "File audio tidak ditemukan", Toast.LENGTH_LONG).show()
@@ -296,7 +299,11 @@
 
         val serviceIntent = Intent(requireContext(), UploadForegroundService::class.java).apply {
             putExtra(UploadForegroundService.EXTRA_TOPIC, topic)
-            putExtra(UploadForegroundService.EXTRA_DEVICE_ID, deviceId)
+            if (userId.isNotEmpty()){
+                putExtra(UploadForegroundService.EXTRA_USER_ID, userId)
+            }else{
+                putExtra(UploadForegroundService.EXTRA_DEVICE_ID, deviceId)
+            }
             putExtra(UploadForegroundService.EXTRA_FILE_PATH, tempFile!!.absolutePath)
         }
 
Index: app/src/main/java/com/example/kaizenspeaking/ui/analyze/Service/UploadForegroundService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.kaizenspeaking.ui.analyze.Service\r\n\r\nimport android.annotation.SuppressLint\r\nimport android.app.Notification\r\nimport android.app.NotificationChannel\r\nimport android.app.NotificationManager\r\nimport android.app.PendingIntent\r\nimport android.app.Service\r\nimport android.content.Context\r\nimport android.content.Intent\r\nimport android.os.Build\r\nimport android.os.Bundle\r\nimport android.os.IBinder\r\nimport android.util.Log\r\nimport androidx.core.app.NotificationCompat\r\nimport androidx.localbroadcastmanager.content.LocalBroadcastManager\r\nimport androidx.navigation.NavDeepLinkBuilder\r\nimport com.example.kaizenspeaking.R\r\nimport com.example.kaizenspeaking.ui.analyze.data.response.AnalyzeResponse\r\nimport com.example.kaizenspeaking.ui.analyze.data.response.Score\r\nimport com.example.kaizenspeaking.ui.analyze.data.retrofit.ApiConfig\r\nimport com.google.gson.Gson\r\nimport com.google.gson.JsonObject\r\nimport kotlinx.coroutines.CoroutineScope\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.Job\r\nimport kotlinx.coroutines.launch\r\nimport okhttp3.MediaType.Companion.toMediaType\r\nimport okhttp3.MultipartBody\r\nimport okhttp3.RequestBody.Companion.asRequestBody\r\nimport okhttp3.RequestBody.Companion.toRequestBody\r\nimport java.io.File\r\n\r\nclass UploadForegroundService : Service() {\r\n\r\n    companion object {\r\n        private const val NOTIFICATION_ID = 1\r\n        private const val CHANNEL_ID = \"upload_channel\"\r\n        private const val CHANNEL_NAME = \"Upload Service\"\r\n        const val EXTRA_TOPIC = \"extra_topic\"\r\n        const val EXTRA_DEVICE_ID = \"extra_device_id\"\r\n        const val EXTRA_FILE_PATH = \"extra_file_path\"\r\n    }\r\n\r\n    private val serviceJob = Job()\r\n    private val serviceScope = CoroutineScope(Dispatchers.IO + serviceJob)\r\n\r\n    override fun onBind(intent: Intent?): IBinder? = null\r\n\r\n    @SuppressLint(\"ForegroundServiceType\")\r\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\r\n        val topic = intent?.getStringExtra(EXTRA_TOPIC)\r\n        val deviceId = intent?.getStringExtra(EXTRA_DEVICE_ID)\r\n        val filePath = intent?.getStringExtra(EXTRA_FILE_PATH)\r\n\r\n        if (topic != null && deviceId != null && filePath != null) {\r\n            startForeground(NOTIFICATION_ID, createNotification(\"Menganalisis rekaman....\"))\r\n            serviceScope.launch {\r\n                try {\r\n                    val file = File(filePath)\r\n                    val response = uploadData(topic, deviceId, file)\r\n                    if (response != null) {\r\n                        // Kirim broadcast ke fragment\r\n                        val resultIntent = Intent(\"ANALYZE_RESULT\").apply {\r\n                            putExtra(\"result\", response)\r\n                        }\r\n                        LocalBroadcastManager.getInstance(this@UploadForegroundService).sendBroadcast(resultIntent)\r\n\r\n                        // Buat notifikasi\r\n                        val navDeepLinkIntent = NavDeepLinkBuilder(this@UploadForegroundService)\r\n                            .setGraph(R.navigation.mobile_navigation)\r\n                            .setDestination(R.id.analyzeResultFragment)\r\n                            .setArguments(Bundle().apply {\r\n                                putParcelable(\"result\", response)\r\n                            })\r\n                            .createPendingIntent()\r\n\r\n                        val finishedNotification = createNotification(\r\n                            \"Analisis selesai!\",\r\n                            navDeepLinkIntent\r\n                        )\r\n                        val notificationManager =\r\n                            getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\r\n                        notificationManager.notify(NOTIFICATION_ID, finishedNotification)\r\n                    }\r\n                } catch (e: Exception) {\r\n                    e.printStackTrace()\r\n                } finally {\r\n                    stopForeground(true)\r\n                    stopSelf()\r\n                }\r\n            }\r\n        }\r\n        return START_NOT_STICKY\r\n    }\r\n\r\n    private suspend fun uploadData(topic: String, deviceId: String, file: File): AnalyzeResponse? {\r\n        val topicRequestBody = topic.toRequestBody(\"text/plain\".toMediaType())\r\n        val deviceIdRequestBody = deviceId.toRequestBody(\"text/plain\".toMediaType())\r\n        val fileRequestBody = file.asRequestBody(\"audio/m4a\".toMediaType())\r\n        val multipartFile = MultipartBody.Part.createFormData(\"file\", file.name, fileRequestBody)\r\n\r\n        return try {\r\n            val response = ApiConfig.instance.uploadRecording(topicRequestBody, multipartFile, deviceIdRequestBody)\r\n            if (response.isSuccessful) {\r\n                val rawResponse = response.body()?.string()\r\n                parseAnalyzeResponse(rawResponse)\r\n            } else {\r\n                null\r\n            }\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n            null\r\n        }\r\n    }\r\n\r\n    private fun createNotification(content: String, pendingIntent: PendingIntent? = null): Notification {\r\n        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            val channel = NotificationChannel(\r\n                CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_LOW\r\n            )\r\n            notificationManager.createNotificationChannel(channel)\r\n        }\r\n\r\n        return NotificationCompat.Builder(this, CHANNEL_ID)\r\n            .setContentTitle(\"Analisis Rekaman\")\r\n            .setContentText(content)\r\n            .setSmallIcon(R.drawable.ic_notifications_black_24dp)\r\n            .setContentIntent(pendingIntent)\r\n            .build()\r\n    }\r\n\r\n    private fun parseAnalyzeResponse(rawResponse: String?): AnalyzeResponse? {\r\n        if (rawResponse.isNullOrEmpty()) return null\r\n\r\n        val gson = Gson()\r\n        val lines = rawResponse.split(\"\\n\").filter { it.isNotBlank() }\r\n\r\n        var score: Score? = null\r\n        val words = mutableListOf<String>()\r\n\r\n        for (line in lines) {\r\n            try {\r\n                if (line.contains(\"score\")) {\r\n                    val jsonObject = gson.fromJson(line, JsonObject::class.java)\r\n                    val scoreObject = jsonObject[\"score\"]?.asJsonObject\r\n                    if (scoreObject != null) {\r\n                        score = Score(\r\n                            kejelasan = scoreObject[\"Kejelasan Berbicara\"]?.asString,\r\n                            diksi = scoreObject[\"Penggunaan Diksi\"]?.asString,\r\n                            kelancaran = scoreObject[\"Kelancaran dan Intonasi\"]?.asString,\r\n                            emosi = scoreObject[\"Emosional dan Keterlibatan Audiens\"]?.asString\r\n                        )\r\n                    }\r\n                } else if (line.contains(\"word\")) {\r\n                    val wordObject = gson.fromJson(line, JsonObject::class.java)\r\n                    wordObject[\"word\"]?.let { words.add(it.asString) }\r\n                }\r\n                Log.d(\"ParseResponse\", \"Score: $score\")\r\n                Log.d(\"ParseResponse\", \"Words: $words\")\r\n            } catch (e: Exception) {\r\n                e.printStackTrace()\r\n                Log.e(\"ParseError\", \"Error parsing response: ${e.message}\")\r\n            }\r\n        }\r\n\r\n        return if (score != null) {\r\n            AnalyzeResponse(score, words)\r\n        } else {\r\n            null\r\n        }\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        serviceJob.cancel()\r\n    }\r\n}
===================================================================
diff --git a/app/src/main/java/com/example/kaizenspeaking/ui/analyze/Service/UploadForegroundService.kt b/app/src/main/java/com/example/kaizenspeaking/ui/analyze/Service/UploadForegroundService.kt
--- a/app/src/main/java/com/example/kaizenspeaking/ui/analyze/Service/UploadForegroundService.kt	(revision 06bdbe1ca1ccd161f0e4415756eae062abe769cf)
+++ b/app/src/main/java/com/example/kaizenspeaking/ui/analyze/Service/UploadForegroundService.kt	(date 1733110598150)
@@ -39,6 +39,7 @@
         private const val CHANNEL_NAME = "Upload Service"
         const val EXTRA_TOPIC = "extra_topic"
         const val EXTRA_DEVICE_ID = "extra_device_id"
+        const val EXTRA_USER_ID = "extra_user_id"
         const val EXTRA_FILE_PATH = "extra_file_path"
     }
 
@@ -50,15 +51,15 @@
     @SuppressLint("ForegroundServiceType")
     override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
         val topic = intent?.getStringExtra(EXTRA_TOPIC)
-        val deviceId = intent?.getStringExtra(EXTRA_DEVICE_ID)
+        val id = intent?.getStringExtra(EXTRA_USER_ID) ?: intent?.getStringExtra(EXTRA_DEVICE_ID)
         val filePath = intent?.getStringExtra(EXTRA_FILE_PATH)
 
-        if (topic != null && deviceId != null && filePath != null) {
+        if (topic != null && id != null && filePath != null) {
             startForeground(NOTIFICATION_ID, createNotification("Menganalisis rekaman...."))
             serviceScope.launch {
                 try {
                     val file = File(filePath)
-                    val response = uploadData(topic, deviceId, file)
+                    val response = uploadData(topic, id, file)
                     if (response != null) {
                         // Kirim broadcast ke fragment
                         val resultIntent = Intent("ANALYZE_RESULT").apply {
@@ -94,14 +95,14 @@
         return START_NOT_STICKY
     }
 
-    private suspend fun uploadData(topic: String, deviceId: String, file: File): AnalyzeResponse? {
+    private suspend fun uploadData(topic: String, id: String, file: File): AnalyzeResponse? {
         val topicRequestBody = topic.toRequestBody("text/plain".toMediaType())
-        val deviceIdRequestBody = deviceId.toRequestBody("text/plain".toMediaType())
+        val idRequestBody = id.toRequestBody("text/plain".toMediaType())
         val fileRequestBody = file.asRequestBody("audio/m4a".toMediaType())
         val multipartFile = MultipartBody.Part.createFormData("file", file.name, fileRequestBody)
 
         return try {
-            val response = ApiConfig.instance.uploadRecording(topicRequestBody, multipartFile, deviceIdRequestBody)
+            val response = ApiConfig.instance.uploadRecording(topicRequestBody, multipartFile, idRequestBody)
             if (response.isSuccessful) {
                 val rawResponse = response.body()?.string()
                 parseAnalyzeResponse(rawResponse)
Index: app/src/main/java/com/example/kaizenspeaking/ui/analyze/data/retrofit/ApiConfig.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.kaizenspeaking.ui.analyze.data.retrofit\r\n\r\nimport okhttp3.OkHttpClient\r\nimport okhttp3.logging.HttpLoggingInterceptor\r\nimport retrofit2.Retrofit\r\nimport retrofit2.converter.gson.GsonConverterFactory\r\nimport java.util.concurrent.TimeUnit\r\n\r\nobject ApiConfig {\r\n    private const val BASE_URL = \"https://kaizen-server-hc5od2n5nq-et.a.run.app/\"\r\n\r\n    private val client = OkHttpClient.Builder()\r\n        .connectTimeout(5, TimeUnit.MINUTES)  // Timeout untuk koneksi\r\n        .readTimeout(5, TimeUnit.MINUTES)     // Timeout untuk membaca data\r\n        .writeTimeout(5, TimeUnit.MINUTES)    // Timeout untuk menulis data\r\n        .addInterceptor(HttpLoggingInterceptor().apply {\r\n            level = HttpLoggingInterceptor.Level.BODY\r\n        })\r\n        .build()\r\n\r\n    val instance: ApiService by lazy {\r\n        Retrofit.Builder()\r\n            .baseUrl(BASE_URL)\r\n            .addConverterFactory(GsonConverterFactory.create())\r\n            .client(client)\r\n            .build()\r\n            .create(ApiService::class.java)\r\n    }\r\n}\r\n
===================================================================
diff --git a/app/src/main/java/com/example/kaizenspeaking/ui/analyze/data/retrofit/ApiConfig.kt b/app/src/main/java/com/example/kaizenspeaking/ui/analyze/data/retrofit/ApiConfig.kt
--- a/app/src/main/java/com/example/kaizenspeaking/ui/analyze/data/retrofit/ApiConfig.kt	(revision 06bdbe1ca1ccd161f0e4415756eae062abe769cf)
+++ b/app/src/main/java/com/example/kaizenspeaking/ui/analyze/data/retrofit/ApiConfig.kt	(date 1733112313880)
@@ -10,9 +10,9 @@
     private const val BASE_URL = "https://kaizen-server-hc5od2n5nq-et.a.run.app/"
 
     private val client = OkHttpClient.Builder()
-        .connectTimeout(5, TimeUnit.MINUTES)  // Timeout untuk koneksi
-        .readTimeout(5, TimeUnit.MINUTES)     // Timeout untuk membaca data
-        .writeTimeout(5, TimeUnit.MINUTES)    // Timeout untuk menulis data
+        .connectTimeout(6, TimeUnit.MINUTES)  // Timeout untuk koneksi
+        .readTimeout(6, TimeUnit.MINUTES)     // Timeout untuk membaca data
+        .writeTimeout(6, TimeUnit.MINUTES)    // Timeout untuk menulis data
         .addInterceptor(HttpLoggingInterceptor().apply {
             level = HttpLoggingInterceptor.Level.BODY
         })
